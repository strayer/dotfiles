-- items/mealplan.lua - Modern mealplan module with lua-http and lua-cjson
--
-- This module requires the following Lua modules to be installed:
-- - lua-http (for making HTTP requests)
-- - lua-cjson (for parsing JSON)

local colors = require("lib.colors")
local settings = require("lib.settings")

-- Only load on work machine
if not settings.is_work_machine then
  return
end

local http_request = require("http.request")
local cjson = require("cjson")

-- Configuration constants
local CONFIG = {
  api_url = "{{ .mealplan_url }}",
  min_price_filter = 1.0, -- Minimum price in euros to show meals
  request_timeout = 10, -- HTTP request timeout in seconds
}

-- Food type icon mapping
local FOOD_TYPE_ICONS = {
  MEAT = "îŠ¥", -- nf-fae-meat
  BEEF = "î»±", -- nf-fa-cow
  PORK = "ó±€†", -- nf-md-pig_variant
  POULTRY = "ó±—†", -- nf-md-bird
  FISH = "ó°ˆº", -- nf-md-fish
  VEGGIE = "îˆ¯", -- nf-fae-plant
  STEW = "ó°™š", -- nf-md-pot_steam
  GRAND_DESSERT = "ó°¦Œ", -- nf-md-muffin
}

-- Create main mealplan item first
local mealplan = sbar.add("item", "right.mealplan", {
  position = "right",
  icon = {
    padding_left = 7,
  },
  update_freq = 60,
  popup = {
    align = "center",
  },
})

-- Module state
local M = {
  popup_items = {},
  meals = nil, -- In-memory store for meal data
  last_fetch_date = nil, -- The date of the last successful fetch
  friday_dessert = nil, -- Friday's grand dessert
  last_friday_fetch_date = nil, -- The date of the last Friday dessert fetch
}

-- HTTP client with lua-http
local function fetch_mealplan_data(date_str)
  local url = CONFIG.api_url .. "?start_date=" .. date_str .. "&end_date=" .. date_str

  -- Create request with timeout
  local request = http_request.new_from_uri(url)
  request.headers:upsert("user-agent", "SketchyBar-Mealplan/1.0")

  local headers, stream = request:go(CONFIG.request_timeout)

  if not headers then
    return nil, "Connection failed"
  end

  local status = headers:get(":status")
  if status == "404" then
    -- 404 means no meal plans available for this date - return empty data
    return {}
  elseif status ~= "200" then
    return nil, "HTTP error: " .. status
  end

  local body = stream:get_body_as_string()

  -- Parse JSON with lua-cjson
  local success, data = pcall(cjson.decode, body)
  if not success then
    return nil, "JSON parse error: " .. tostring(data)
  end

  return data
end

-- Data processing
local function filter_and_process_meals(api_data)
  local today_items = {}
  local today_str = os.date("%Y-%m-%d")

  -- Handle empty API response (no meals available)
  if not api_data or #api_data == 0 then
    return {}
  end

  -- Find today's data in API response (array of day objects)
  for _, day_data in ipairs(api_data) do
    if day_data.date == today_str then
      today_items = day_data.items or {}
      break
    end
  end

  -- Filter meals with price >= 1â‚¬ and format them
  local filtered_meals = {}
  for _, meal in ipairs(today_items) do
    local price = tonumber(meal.price) or 0
    if price >= CONFIG.min_price_filter then
      table.insert(filtered_meals, {
        name = (meal.short_name ~= cjson.null and meal.short_name) or meal.name or "Unknown",
        price = string.format("%.2f", price),
        food_type = meal.food_type ~= cjson.null and meal.food_type or "",
      })
    end
  end

  return filtered_meals
end

-- Get next Friday's date (or this Friday if today is not Friday)
local function get_next_friday_date()
  local today = os.time()
  local weekday = tonumber(os.date("%w", today)) -- 0=Sunday, ..., 6=Saturday, 5=Friday
  
  if weekday == 5 then -- Today is Friday
    return nil -- Don't show Friday dessert on Friday itself
  end
  
  -- Calculate days until next Friday
  local days_until_friday = (5 - weekday) % 7
  if days_until_friday == 0 then
    days_until_friday = 7 -- Next Friday is in a week
  end
  
  local friday_time = today + (days_until_friday * 24 * 60 * 60)
  return os.date("%Y-%m-%d", friday_time)
end

-- Find GRAND_DESSERT from Friday's meal data
local function find_friday_dessert(api_data, friday_date)
  if not api_data or #api_data == 0 or not friday_date then
    return nil
  end
  
  -- Find Friday's data in API response
  local friday_items = {}
  for _, day_data in ipairs(api_data) do
    if day_data.date == friday_date then
      friday_items = day_data.items or {}
      break
    end
  end
  
  -- Look for GRAND_DESSERT
  for _, meal in ipairs(friday_items) do
    if meal.food_type == "GRAND_DESSERT" then
      return {
        name = (meal.short_name ~= cjson.null and meal.short_name) or meal.name or "Unknown Dessert",
        price = string.format("%.2f", tonumber(meal.price) or 0),
      }
    end
  end
  
  return nil
end

-- Invalidation strategy
local function should_fetch_new_data()
  local today_str = os.date("%Y-%m-%d")

  -- Always fetch if we have no data or if the data is for a previous day
  if not M.meals or M.last_fetch_date ~= today_str then
    return true
  end

  -- If we have an empty list of meals, check if it's a weekend
  if #M.meals == 0 then
    local weekday = tonumber(os.date("%w")) -- 0=Sunday, ..., 6=Saturday
    if weekday == 0 or weekday == 6 then
      -- It's the weekend and we have no meals, don't refetch
      return false
    end
    -- It's a weekday and we have no meals, keep trying
    return true
  end

  -- We have data for today, no need to refetch
  return false
end

-- Check if we should fetch Friday dessert data
local function should_fetch_friday_dessert()
  local friday_date = get_next_friday_date()
  if not friday_date then
    return false -- Today is Friday, don't fetch
  end
  
  -- Always fetch if we have no Friday data or if the Friday date changed
  if not M.friday_dessert or M.last_friday_fetch_date ~= friday_date then
    return true, friday_date
  end
  
  return false, friday_date
end

-- Display system
local function clear_popup_items()
  for _, item in ipairs(M.popup_items) do
    sbar.remove(item.name)
  end
  M.popup_items = {}
end

local function update_display(meals)
  local theme_colors = colors.get_colors()
  clear_popup_items()

  if #meals == 0 then
    -- No meals available
    mealplan:set({
      icon = { string = "ó°—³", color = theme_colors.item_primary, padding_right = 7 },
      label = { drawing = false },
      background = { color = theme_colors.item_background },
      popup = { drawing = false },
    })
  else
    -- Meals available
    mealplan:set({
      icon = { string = "ó±¤–", color = theme_colors.item_primary, padding_right = 4 },
      label = { string = tostring(#meals), color = theme_colors.item_primary, drawing = true },
      background = { color = theme_colors.item_background },
    })

    -- Create popup items for each meal
    for i, meal in ipairs(meals) do
      local item_name = "meal_item." .. i
      local food_icon = FOOD_TYPE_ICONS[meal.food_type] or "ðŸ½ï¸"

      local popup_item = sbar.add("item", item_name, {
        position = "popup." .. mealplan.name,
        icon = { string = food_icon, color = theme_colors.item_primary },
        label = { string = meal.name .. " (" .. meal.price .. "â‚¬)", color = theme_colors.item_primary },
        background = { color = theme_colors.item_background },
      })
      table.insert(M.popup_items, popup_item)
    end
    
    -- Add Friday dessert if available
    if M.friday_dessert then
      -- Add separator with title
      local separator_item = sbar.add("item", "dessert_separator", {
        position = "popup." .. mealplan.name,
        icon = { drawing = false },
        label = { string = "âœ¦ â”€â”€ Freitagsdessert â”€â”€ âœ¦", color = theme_colors.item_secondary },
        background = { color = theme_colors.item_background },
      })
      table.insert(M.popup_items, separator_item)
      
      -- Add Friday dessert item
      local dessert_icon = FOOD_TYPE_ICONS["GRAND_DESSERT"] or "ó°¦Œ"
      
      local dessert_item = sbar.add("item", "friday_dessert", {
        position = "popup." .. mealplan.name,
        icon = { string = dessert_icon, color = theme_colors.item_primary },
        label = { string = M.friday_dessert.name .. " (" .. M.friday_dessert.price .. "â‚¬)", color = theme_colors.item_primary },
        background = { color = theme_colors.item_background },
      })
      table.insert(M.popup_items, dessert_item)
    end
  end
end

-- Error handling
local function show_error_state()
  local theme_colors = colors.get_colors()
  mealplan:set({
    icon = { string = "ó°…–", color = theme_colors.critical, padding_right = 7 },
    label = { drawing = false },
    background = { color = theme_colors.item_background },
    popup = { drawing = false },
  })
end

-- Main update function
local function update_mealplan()
  local fetch_today = should_fetch_new_data()
  local fetch_friday, friday_date = should_fetch_friday_dessert()
  
  -- Fetch today's data if needed
  if fetch_today then
    local today_str = os.date("%Y-%m-%d")
    local api_data, _ = fetch_mealplan_data(today_str)

    if api_data then
      M.meals = filter_and_process_meals(api_data)
      M.last_fetch_date = today_str
    else
      -- API failed - keep existing data if available
      if not M.meals then
        show_error_state()
        return
      end
    end
  end
  
  -- Fetch Friday dessert if needed
  if fetch_friday and friday_date then
    local friday_api_data, _ = fetch_mealplan_data(friday_date)
    if friday_api_data then
      M.friday_dessert = find_friday_dessert(friday_api_data, friday_date)
      M.last_friday_fetch_date = friday_date
    end
    -- If Friday fetch fails, keep existing friday_dessert data
  end
  
  -- Clear Friday dessert if today is Friday
  if not friday_date then
    M.friday_dessert = nil
    M.last_friday_fetch_date = nil
  end

  -- Update display with current data
  if M.meals then
    update_display(M.meals)
  else
    show_error_state()
  end
end

-- Mouse events for popup control
mealplan:subscribe({ "mouse.entered", "mouse.exited", "mouse.exited.global" }, function(env)
  if env.SENDER == "mouse.entered" and M.meals and (#M.meals > 0 or M.friday_dessert) then
    mealplan:set({ popup = { drawing = true } })
  else
    mealplan:set({ popup = { drawing = false } })
  end
end)

-- Periodic and system events
mealplan:subscribe("routine", update_mealplan)
mealplan:subscribe("system_woke", update_mealplan)
mealplan:subscribe("forced", update_mealplan)
mealplan:subscribe("theme_change", function()
  -- Refresh display with new theme colors using current data
  if M.meals then
    update_display(M.meals)
  else
    -- No data, just update the icon color
    local theme_colors = colors.get_colors()
    mealplan:set({
      icon = { color = theme_colors.warning },
      background = { color = theme_colors.item_background },
    })
  end
end)

-- Initial update
update_mealplan()

-- vim: ft=lua
